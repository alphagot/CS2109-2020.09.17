C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "DP80390CPU.H"
   2          #include "common.h"
   3          #include "register.h"
   4          #include "intrins.h"
   5          
   6          //#define FIRE_ALARM_VALUE   0x40
   7          //#define FIRE_ALARM_VALUE   10
   8          //#define QUIT_ALARM_VALUE   (FIRE_ALARM_VALUE-10)
   9          #define SLEF_CHECK_VALUE   0x00
  10          #define SLIENCDE_VALUE     0xFF
  11          
  12          #define SLIENCDE_TIME      50           //静音时间8*50/60=6.667ｓ
  13          #define DETECT_TIME1       1            //8s
  14          #define DETECT_TIME2       1            //2s
  15          #define DETECT_TIME3       2            //1s
  16          #define BZ_TIME                    1            //500ms
  17          #define LED_TIME_NORMAL    8            //正常64ｓ闪一次
  18          #define LED_TIME_SLIENCDE  1            //静音模式下8ｓ闪一次
  19          #define LVD_TIME               5                //低压报警时间4０ｓ
  20          
  21          
  22          #define LED_ON()        PCREG &= ~0x08
  23          #define LED_OFF()       PCREG |= 0x08
  24          
  25          
  26          //unsigned int code BZ_Freq[]={0x560,0x540,0x500,0x300,0x1E0};
  27          //unsigned int code BZ_Freq[]={0x4C0,0x4A0,0x400,0x380,0x270};  //50%占空比最响
  28          //unsigned int code BZ_Freq[]={0x09,0x08,0x07,0x06,0x05};
  29          unsigned int code BZ_Freq[]={0x495,0x490,0x480,0x460,0x430,0x3c0,0x320,0x250};  //50%占空比最响
  30          unsigned char code IRED_ADJ[]=
  31          {
  32          0x4f,0x4e,0x0f,0x0e,
  33          0x4d,0x4c,0x0d,0x0c,
  34          0x4b,0x4a,0x0b,0x0a,
  35          0x49,0x48,0x09,0x08,
  36          0x47,0x46,0x07,0x06,
  37          0x45,0x44,0x05,0x04,
  38          0x43,0x42,0x03,0x02,
  39          };               //发射电流由大变小
  40          unsigned char Smoke_Value;
  41          unsigned char Dark_Value;
  42          unsigned char timer_flag;
  43          unsigned char bz_timer;
  44          unsigned char bz_step;
  45          unsigned char alarm_flag;
  46          unsigned char alarm_value;
  47          unsigned char detect_time;
  48          unsigned char detect_count;
  49          unsigned char sleep_flag;
  50          unsigned char key_flag;
  51          unsigned char rxd_flag;
  52          unsigned char silince_flag;
  53          unsigned char led_falg;
  54          unsigned char led_timer;
  55          unsigned int  silince_time;
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 2   

  56          unsigned char self_check_flag;
  57          unsigned char lvd_flag;
  58          unsigned char lvd_time;
  59          unsigned char FIRE_ALARM_VALUE;
  60          unsigned char QUIT_ALARM_VALUE;
  61          unsigned char delta_value;
  62          unsigned char comm_step;
  63          unsigned char Battery_Value_H;
  64          unsigned char Battery_Value_L;
  65          unsigned int voltage_bak;
  66          unsigned char adjust_flag;
  67          unsigned char silince_time_bak;
  68          unsigned char IRED_Ptr;
  69          unsigned char Charge_Flag;
  70          unsigned char uartr_flag,uartadd,uartdate;
  71          unsigned char ADC_VALUE1;
  72          unsigned char ADC_VALUE2;
  73          unsigned char Smoke_Value2;
  74          
  75          
  76          
  77          void delay_20us(unsigned char N);
  78          void Smoke_Detect();
  79          void BZ_Process();
  80          void Key_Process();
  81          void Other_Process();
  82          void Sleep();
  83          void MCU_Init();
  84          void uart();
  85          void ser_int();
  86          
  87          
  88          void main()
  89          {
  90   1              MCU_Init();
  91   1              ser_int();
  92   1      
  93   1      
  94   1              timer_flag = 0;
  95   1              bz_timer = 0;
  96   1              bz_step = 0;
  97   1              alarm_flag = 0;
  98   1              detect_time = DETECT_TIME1;             //8s
  99   1              detect_count = 0;
 100   1              sleep_flag = 1;
 101   1              key_flag = 0;
 102   1              silince_time = 0;
 103   1              silince_time_bak = 0;
 104   1              silince_flag = 0;
 105   1              led_falg = 0;
 106   1              self_check_flag = 0;
 107   1              lvd_flag = 0;
 108   1              lvd_time = 0;
 109   1              comm_step = 0;
 110   1              voltage_bak = 0;
 111   1              IRED_Ptr = 14;          //设置指针初始位置
 112   1              Charge_Flag = 0;
 113   1              uartr_flag = 0;
 114   1              while(1)
 115   1              {
 116   2                      WDCON |= 0x10;
 117   2                      uart();
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 3   

 118   2      
 119   2      //              Key_Process();
 120   2      //              Smoke_Detect();
 121   2      //              BZ_Process();
 122   2      //              Other_Process();
 123   2      //              Sleep();                  
 124   2              }       
 125   1      
 126   1      
 127   1      }
 128          
 129          void MCU_Init()
 130          {
 131   1              unsigned char i,temp[2];
 132   1              SYS_REG_MASK = 0xA5;
 133   1              SYS_REG1 = 0x58;         //打开看门狗使能，打开低压复位，打开高速振荡器
 134   1              SYS_REG3 = 0x10;         //     
 135   1      //      SYS_REG2 = 0xC2;         //高速时钟4分频，空闲模式              
 136   1      //      SYS_REG4 = 0x0c;         //PWM用高速时钟4分频
 137   1              SYS_REG2 = 0x03;
 138   1              SYS_REG4 = 0x01;         //PWM用高速时钟
 139   1              LXT_START = 0X00;
 140   1      
 141   1              IE = 0x85;                                      //全局中断，int1(),int0()中断使能
 142   1              IP = 0x01;                                              //int0优先
 143   1              TCON = 0x05;                                    //int0,int1为沿触发     
 144   1                
 145   1              
 146   1      
 147   1              BANDGAP_TEMP = 0x05;
 148   1              LDO2_CTRL = 0X03;
 149   1      
 150   1              
 151   1              PADIR = 0x01;
 152   1              PAPU = 0XFe;
 153   1              PAREG = 0x00;
 154   1      
 155   1              PCDIR = 0x08;    //红色led等pc3
 156   1              PCPU = 0XF7;
 157   1              PCREG = 0x08;
 158   1              ADPCR = 0X30;
 159   1      
 160   1      
 161   1      
 162   1              PBDIR = 0x08;                   //pb1输出低电平
 163   1              PBPU = ~0x08;                   //pb1不上拉
 164   1              PBREG = 0x00;
 165   1              PWM_PERIOD0L = 0x98;            //pwm周期为3.4KHz   时钟４Ｍ
 166   1              PWM_PERIOD0H = 0x04;
 167   1      //      PWM_PERIOD0L = 0xe2;            //pwm周期为3.2KHz   时钟４Ｍ
 168   1      //      PWM_PERIOD0H = 0x04;                                                       
 169   1              DZ_CTRL = 0x05;                 //pwm0互补输出,全N模式
 170   1              PWM_CTRL = 0x40;                //pwm0装载，连续输出，初始电平为0  
 171   1      
 172   1              WAKEUP_EDGE_REG = 0x42;         //下降沿唤醒
 173   1      
 174   1      
 175   1              IRED_CTRL = 0x07;               //设置发射电流为125ｍA
 176   1              MISC = 0XC0;                    //pb6复用IRED，pa0复用TXD，pa1复用RXD  
 177   1      
 178   1      /******************uart*********************/
 179   1      /*      MISC |= 0x80;   //复用uart口
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 4   

 180   1              SCON =  0X40;   //方式1,溢出率／３２
 181   1              TTMOD2 = 0x00;  //使用timer1产生波特率，16位计数
 182   1              TMOD = 0x00;    //不分频，４Ｍ
 183   1              TH1 =  0X00;
 184   1              TL1 = 0X0c;             //104ｕｓ，9600ｂｐｓ
 185   1              TTCON = 0x2a;      */
 186   1      /*******************************************/
 187   1      
 188   1      
 189   1              OPA1C0 = 0x27;          //积分增益为16倍
 190   1              OPA1C1 = 0x0c;          //OPA1连接红外接收管
 191   1              OPA1MODE = 0x04;        //设置成开环    
 192   1      
 193   1              LVDC = 0x05;            //2.5V
 194   1              
 195   1      //      TBC = 0xa6;                //TBC开启2s定时
 196   1      //      TBC = 0x08;                //TBC0开启4s定时,TBC1关闭
 197   1      //      TBC = 0X40;
 198   1      //      TBC = 0x84;                //TBC开启0.5s定时
 199   1      //      INTML = 0xf7;      //TBC中断使能
 200   1      //      INTSEL0L = 0x08;   //TBC中断从int0进入  */ 
 201   1               
 202   1      //      TMR3C = 0X58;           //timer3使用低速时钟,并使能
 203   1      //      TMR3L = 0X00;
 204   1      //      TMR3H = 0X06;           //0.125ms*64000=8s
 205   1              INTML = 0XDF;
 206   1              INTMH = 0x0D;      //uart中断使能
 207   1              INTSEL0L = 0X20;         
 208   1      
 209   1              WDCNTM = 0x38;
 210   1              WDCNTH = 0x01;          //8K时钟，10s钟
 211   1      //      WDCNTM = 0x38;
 212   1      //      WDCNTH = 0x00;
 213   1              WDCON = 0x28;           //开启看门狗复位功能
 214   1              WDCON |= 0x10;
 215   1              
 216   1      //      ADPCR |= 0x08;       //PB6为AN3输入
 217   1      //      BANDGAP_TEMP |= 0x02; //打开温度传感器
 218   1      //      LDOC=0X66;      //LDO 2.4v      
 219   1      
 220   1      
 221   1              E2P_ADDRH=0x00; //起始地址
 222   1              E2P_ADDRL=0x00;
 223   1              E2P_CTRL = 0x10;
 224   1              for(i=0;i<2;i++)
 225   1              {
 226   2                 if(i<1)
 227   2                         E2P_CTRL=0x13;       //启动读
 228   2                 else
 229   2                         E2P_CTRL=0x11;       //启动度
 230   2                 while(!(E2P_FLAG&0x01));//判断是否写完
 231   2                 temp[i]=E2P_DATA;
 232   2              } 
 233   1              if(temp[0]!=(~temp[1]))
 234   1              {
 235   2                      FIRE_ALARM_VALUE = 0x60;
 236   2                      alarm_value = FIRE_ALARM_VALUE;
 237   2                      QUIT_ALARM_VALUE = FIRE_ALARM_VALUE - 10;               
 238   2              }
 239   1              else                                       //上电读取报警阈值
 240   1              {
 241   2                      FIRE_ALARM_VALUE = temp[0];
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 5   

 242   2                      alarm_value = FIRE_ALARM_VALUE;
 243   2                      QUIT_ALARM_VALUE = FIRE_ALARM_VALUE - 10;                         
 244   2              }                                         
 245   1              alarm_value = 0xc0;
 246   1              FIRE_ALARM_VALUE = 0xc0;
 247   1      
 248   1      
 249   1              delay_20us(250);
 250   1              delay_20us(250);
 251   1              delay_20us(250);
 252   1              delay_20us(250);
 253   1              delay_20us(250);
 254   1              delay_20us(250);
 255   1              delay_20us(250);
 256   1              delay_20us(250);
 257   1              delay_20us(250);
 258   1              delay_20us(250);
 259   1              delay_20us(250);
 260   1              delay_20us(250);   
 261   1              
 262   1      }
 263          
 264          
 265          void Smoke_Detect()
 266          {        
 267   1         
 268   1              unsigned char i,temp[2];
 269   1              unsigned int vol;
 270   1              if(timer_flag>=detect_time)                               //8s检测一次
 271   1              {
 272   2                      timer_flag = 0;
 273   2                      WDCON |= 0x10;
 274   2                      BANDGAP_TEMP = 0x05;
 275   2                      LDO2_CTRL = 0x03;
 276   2      
 277   2      /*              SYS_REG2 = 0x02;        //切换成低频
 278   2                      _nop_();
 279   2                      _nop_();
 280   2                      _nop_();
 281   2                      _nop_();                
 282   2                      _nop_();
 283   2                      _nop_();
 284   2                      _nop_();
 285   2                      _nop_();
 286   2                      _nop_();
 287   2      
 288   2                      OPA1MODE = 0x10;        //配置成积分模式,并打开200mv偏置
 289   2                      OPA1C1 |= 0x01;         //开启运放              
 290   2                      LDOC = 0x46;
 291   2                      _nop_();
 292   2                      _nop_();
 293   2                      _nop_();
 294   2                      _nop_();
 295   2      
 296   2                      SYS_REG2 = 0xc2;        //切换成高频
 297   2                      _nop_();
 298   2                      _nop_();
 299   2                      _nop_();
 300   2                      _nop_();
 301   2      //              delay_20us(100);                //运放稳定时间
 302   2      */
 303   2                      TMR3C &= ~0x08;         //关闭计数器
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 6   

 304   2                      delay_20us(20);
 305   2                      TMR3L = 0xc0;           //休眠8ms
 306   2                      TMR3H = 0xff; 
 307   2                      TMR3C |= 0x08;          //开启计数器
 308   2                      Charge_Flag = 1;
 309   2                      PCON |= 0X02;   //mcu_stop,给电容充电                   
 310   2                      _nop_();
 311   2                      _nop_();
 312   2                      _nop_();
 313   2                      _nop_();
 314   2                      TMR3C &= ~0x08;         //关闭计数器,到下面检测完成再开启
 315   2                      LDO2_CTRL = 0x00;//关闭LDO2
 316   2                      Charge_Flag = 0;
 317   2                                
 318   2      
 319   2                      OPA1MODE = 0x10;        //配置成积分模式,并打开200mv偏置
 320   2                      OPA1C1 |= 0x01;         //开启运放              
 321   2                      LDOC = 0x46;
 322   2                      delay_20us(20);         //运放稳定时间
 323   2      /******************************电源电压检测*/
 324   2                      LDOC |= 0x20;           //打开LDO到ADC基准
 325   2                      LCDC |= 0X70;
 326   2                      LDOC |= 0X10;
 327   2                      ADCR = 0x3b;            //打开ADC电源，选择内部2.4V为基准,测量AVDD电压
 328   2      //              ADCR = 0x2b;            //打开ADC电源，选择内部2.4V为基准,测量AVDD电压
 329   2                      for(i=0;i<5;i++)
 330   2                      {
 331   3                              ADCR |= 0x80;
 332   3                              ADCR &= ~0x80;          //启动ADC检测
 333   3                              while(ADCR&0x40);       //等待ADC检测结束
 334   3                      }
 335   2                      Battery_Value_H = ADRH;
 336   2                      Battery_Value_L = ADRL;
 337   2                      ADCR = 0x00;
 338   2                      LDOC &= ~0x20;          
 339   2                      LDOC &= ~0X10;
 340   2                      LCDC &= ~0X70;
 341   2      
 342   2              //      4096*2.4*2;//2560为3V,每85个字为0.1V
 343   2                      vol = (((unsigned int)Battery_Value_H)<<4);
 344   2                      vol += (unsigned int)Battery_Value_L>>4;
 345   2      
 346   2      
 347   2       
 348   2                      if(voltage_bak==0x00)   //首次检测
 349   2                      {
 350   3                              adjust_flag = 1;
 351   3                              voltage_bak = vol;      //保存上一次校准时的电压
 352   3                      }
 353   2                      else
 354   2                      {
 355   3                              if((vol>=(voltage_bak+8))||(vol<=(voltage_bak-8)))      //迟滞10mv
 356   3                              {
 357   4                                      adjust_flag = 1;
 358   4                                      voltage_bak = vol;      //保存上一次校准时的电压
 359   4                              }       
 360   3                      }
 361   2      
 362   2                      if(adjust_flag)
 363   2                      {
 364   3                              adjust_flag = 0;
 365   3                              temp[0] = 24;
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 7   

 366   3      
 367   3                              if(vol>2688)            //大于3.15V
 368   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr+1];
 369   3                              else if((vol>2474)&&(vol<=2688))                //大于2.9V
 370   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr];
 371   3                              else if((vol>2389)&&(vol<=2474))                //大于2.8V
 372   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr-1];
 373   3                              else if((vol>2304)&&(vol<=2389))                //大于2.7V
 374   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr-2];
 375   3                              else if((vol>2218)&&(vol<=2304))                //大于2.6V
 376   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr-3];
 377   3                              else if((vol>2176)&&(vol<=2218))                //大于2.55V
 378   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr-4];
 379   3                              else if((vol>2133)&&(vol<=2176))                //大于2.5V
 380   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr-5];
 381   3                              else if((vol>2090)&&(vol<=2133))                //大于2.45V
 382   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr-7]; 
 383   3                              else if((vol>2048)&&(vol<=2090))                //大于2.4V
 384   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr-9];
 385   3                              else if((vol>2005)&&(vol<=2048))                //大于2.35V
 386   3                              IRED_CTRL = IRED_ADJ[IRED_Ptr-11];
 387   3      
 388   3                      }       
 389   2                      
 390   2      
 391   2      
 392   2      /****************************************************/
 393   2      //              temp[0] = 10;
 394   2                      BANDGAP_TEMP = 0x01;
 395   2                      OPA1MODE |= 0x01;       //Sw_integ
 396   2      
 397   2      //              for(i=temp[0];i>0;i--);
 398   2                      delay_20us(5);
 399   2      
 400   2                      OPA1MODE |= 0x02;
 401   2                      IRED_CTRL &= ~0x20;     //IRED关闭，积分保持
 402   2                      LDOC |= 0x20;           //打开LDO到ADC基准       
 403   2                      ADCR = 0x36;            //打开ADC电源，选择内部2.4V为基准
 404   2                      ADCR |= 0x80;
 405   2                      ADCR &= ~0x80;          //启动ADC检测
 406   2                      while(ADCR&0x40);       //等待ADC检测结束
 407   2                      Dark_Value = ADRH;      //暗电流检测，取ADC高8位
 408   2                      ADCR = 0x00;
 409   2                      LDOC &= ~0x20;
 410   2                      OPA1MODE &= ~0x03;
 411   2      
 412   2      /*****************必须按照该时序**************/         
 413   2                      OPA1MODE |= 0x02;
 414   2                      IRED_CTRL |= 0x20;      //IRED使能
 415   2                      OPA1MODE &= ~0x02;
 416   2                      OPA1MODE |= 0x01;       //Sw_integ
 417   2      
 418   2      //              for(i=temp[0];i>0;i--);
 419   2                      delay_20us(5);
 420   2      
 421   2                      OPA1MODE |= 0x02;        
 422   2                      IRED_CTRL &= ~0x20;     //IRED关闭，积分保持
 423   2      /********************************************/
 424   2      
 425   2                      LVDC |= 0x10;   //开启低压检测,需提前开启
 426   2      
 427   2                      LDOC |= 0x20;
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 8   

 428   2                      ADCR = 0x36;            //打开ADC电源，选择内部2.4V为基准
 429   2                      ADCR |= 0x80;
 430   2                      ADCR &= ~0x80;          //启动ADC检测
 431   2                      while(ADCR&0x40);       //等待ADC检测结束
 432   2                      Smoke_Value = ADRH;     //光电流检测，取ADC高8位
 433   2                      ADCR = 0x00;
 434   2                      LDOC = 0x00;
 435   2                      //LED_ON();
 436   2                      if(LVDC&0x20)
 437   2                      {
 438   3                          
 439   3                              lvd_flag = 1;
 440   3                      }
 441   2                      else
 442   2                      {
 443   3                              lvd_flag = 0;
 444   3                              lvd_time = 0;
 445   3                      }
 446   2                      LVDC &= ~0x10;  //关闭低压检测
 447   2      
 448   2                      OPA1MODE = 0x04;        //关闭所有开关并配置成开环模式
 449   2                      BANDGAP_TEMP = 0x04;
 450   2              //      LDO2_CTRL = 0x00;//关闭LDO2
 451   2                      OPA1C1 &= ~0x01;        //关闭运放
 452   2                      
 453   2      
 454   2                      if(Smoke_Value>=Dark_Value)
 455   2                      Smoke_Value = Smoke_Value - Dark_Value;
 456   2                      else
 457   2                      Smoke_Value = 0;
 458   2      
 459   2      
 460   2      //              Smoke_Value = 0xff;
 461   2      
 462   2                      if(rxd_flag==2)         //读烟雾值
 463   2                      {
 464   3                              SBUF = Smoke_Value;
 465   3                      /*      SBUF = Battery_Value_H;
 466   3                              while(rxd_flag);
 467   3                              rxd_flag = 1;
 468   3                              SBUF = Battery_Value_L;*/       
 469   3                              while(rxd_flag);
 470   3                              INTMH |= 0x02;
 471   3                              MISC &= ~0x80;  //复用IO口
 472   3                      }
 473   2                      else if(rxd_flag==3)      //标定
 474   2                      {
 475   3                              temp[0] = Smoke_Value + delta_value;
 476   3                              temp[1] = ~temp[0];
 477   3                              E2P_ADDRH=0x00; //E2地址
 478   3                              E2P_ADDRL=0x00;
 479   3                              E2P_CTRL = 0x20;
 480   3                              for(i=0;i<2;i++)
 481   3                              {
 482   4                                 E2P_DATA=temp[i];//数据
 483   4                                 if(i<1)
 484   4                                         E2P_CTRL=0x23;       //启动写
 485   4                                 else
 486   4                                         E2P_CTRL=0x21;       //启动写最后一个字节
 487   4                                 while(!(E2P_FLAG&0x02));//判断是否写完       
 488   4                              } 
 489   3              //              FIRE_ALARM_VALUE = Smoke_Value + delta_value;
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 9   

 490   3              //              QUIT_ALARM_VALUE = FIRE_ALARM_VALUE - 10;
 491   3              //              alarm_value = FIRE_ALARM_VALUE;
 492   3      
 493   3                              IRED_CTRL = delta_value;
 494   3      
 495   3                              SBUF = Smoke_Value + delta_value;
 496   3                              while(rxd_flag);
 497   3                              INTMH |= 0x02;
 498   3                              MISC &= ~0x80;  //复用IO口
 499   3                      }
 500   2      
 501   2                      if((!silince_flag)||(self_check_flag))          //非消音状态或者自检
 502   2                      {
 503   3                              if(Smoke_Value>alarm_value)
 504   3                              {
 505   4                              //      PAREG = ~PAREG;
 506   4                                      detect_count++;
 507   4                                      if(detect_count>3)              //防止溢出
 508   4                                      detect_count = 3;
 509   4                                      if(detect_count==1)
 510   4                                      {
 511   5                                              detect_time = DETECT_TIME1;
 512   5                                              TMR3L = 0x80;           //间隔2s
 513   5                                              TMR3H = 0xc1; 
 514   5                                              TMR3C |= 0x08;          //开启计数
 515   5                                      }
 516   4                                      else if(detect_count==2)
 517   4                                      {
 518   5                                              detect_time = DETECT_TIME2;
 519   5                                              TMR3L = 0xc0;           //间隔1s
 520   5                                              TMR3H = 0xe0; 
 521   5                                              TMR3C |= 0x08;          //开启计数
 522   5                                      }
 523   4                                      else
 524   4                                      {
 525   5                                              detect_time = DETECT_TIME3;
 526   5                              //              if(alarm_flag==0)
 527   5                                              {
 528   6                                                      TMR3L = 0x60;           //间隔0.5
 529   6                                                      TMR3H = 0xf0; 
 530   6                                                      TMR3C |= 0x08;          //开启计数
 531   6                                              }
 532   5                                              alarm_flag = 1;
 533   5                                              bz_timer = BZ_TIME;
 534   5      //                                      PAREG = ~PAREG;
 535   5                                      }
 536   4                                      led_falg = 1;
 537   4                                      if(!self_check_flag)
 538   4                                      alarm_value = QUIT_ALARM_VALUE;
 539   4      
 540   4                                      
 541   4                              }
 542   3                              else     //火警取消，恢复初始
 543   3                              {
 544   4                                      detect_count = 0;
 545   4                                      detect_time = DETECT_TIME1;
 546   4                                      alarm_value = FIRE_ALARM_VALUE;
 547   4                                      alarm_flag = 0;
 548   4                                      bz_timer = 0;
 549   4                                      PWM_CTRL &= ~0x01;
 550   4                                      sleep_flag = 1;
 551   4                                      bz_step = 0;
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 10  

 552   4                                      TMR3L = 0x00;           //休眠8s
 553   4                                      TMR3H = 0x06; 
 554   4                                      TMR3C |= 0x08;          //开启计数
 555   4                              }
 556   3                      }
 557   2                      else             //消音状态下,开启8s定时器
 558   2                      {
 559   3                              TMR3L = 0x00;           //休眠8s
 560   3                              TMR3H = 0x06; 
 561   3                              TMR3C |= 0x08;          //开启计数
 562   3                      }
 563   2                      led_timer++;
 564   2                      if(!silince_flag)
 565   2                      {
 566   3                              if(led_timer>=LED_TIME_NORMAL)
 567   3                              {
 568   4                                      led_falg = 1;
 569   4                                      led_timer = 0;
 570   4                              }
 571   3                      }
 572   2                      else
 573   2                      {
 574   3                              if(led_timer>=LED_TIME_SLIENCDE)
 575   3                              {
 576   4                                      led_falg = 1;
 577   4                                      led_timer = 0;
 578   4                              }
 579   3                      }                        
 580   2              } 
 581   1      }
 582          
 583          
 584          void BZ_Process()
 585          {
 586   1              if((bz_timer>=BZ_TIME)&&(alarm_flag))                     //报警声音处理
 587   1              {
 588   2                      led_falg = 1;
 589   2                      bz_timer = 0;
 590   2                      lvd_time = 0;                     //报警时低压报警时间清零
 591   2                      if(PWM_CTRL&0x01)
 592   2                      {
 593   3                              PWM_CTRL &= ~0x01;
 594   3                              sleep_flag = 1;
 595   3                      }
 596   2                      else
 597   2                      {
 598   3                              if(bz_step>=8)
 599   3                              bz_step = 7;
 600   3                              PWM_PULSE0L = BZ_Freq[bz_step]&0x00ff;
 601   3                              PWM_PULSE0H = BZ_Freq[bz_step]>>8;
 602   3                              PWM_CTRL |= 0x40;
 603   3                              PWM_CTRL |= 0x01;
 604   3                              bz_step++;
 605   3                              sleep_flag = 0;
 606   3                      }
 607   2              }
 608   1      }
 609          
 610          
 611          
 612          void Key_Process()
 613          {
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 11  

 614   1              if(((PAREG&0x40)==0x00)&&(!key_flag))            //按键按下
 615   1              {
 616   2                      delay_20us(250);
 617   2                      if(((PAREG&0x40)==0x00)&&(!key_flag))            //按键按下
 618   2                      {
 619   3                              key_flag = 1;
 620   3                              
 621   3                              if(alarm_flag==1)                 //消音
 622   3                              {
 623   4                                      silince_flag = 1;
 624   4                                      alarm_value = SLIENCDE_VALUE;
 625   4                                      detect_count = 0;
 626   4                                      detect_time = DETECT_TIME1;
 627   4                                      timer_flag = 0;
 628   4                                      alarm_flag = 0;
 629   4                                      PWM_CTRL &= ~0x01;                 //关闭蜂鸣器
 630   4                                      sleep_flag = 1;
 631   4                                      bz_timer = 0;
 632   4                                      TMR3C &= ~0x08;         //关闭计数器
 633   4                                      delay_20us(20);
 634   4                                      TMR3L = 0x00;           //间隔8s
 635   4                                      TMR3H = 0x06; 
 636   4                                      TMR3C |= 0x08;
 637   4      
 638   4                              }
 639   3                              else                                      //自检
 640   3                              {
 641   4                                      self_check_flag = 1;
 642   4                                      alarm_value = SLEF_CHECK_VALUE;
 643   4                                      detect_count = 2;
 644   4                                      detect_time = DETECT_TIME3;
 645   4                                      timer_flag = 1;
 646   4      
 647   4                                      if(silince_flag)
 648   4                                      silince_time_bak = silince_time;
 649   4      
 650   4                                      TMR3C &= ~0x08;         //关闭计数器
 651   4                                      delay_20us(20);
 652   4                                      TMR3L = 0x60;           //间隔0.5s
 653   4                                      TMR3H = 0xf0; 
 654   4                                      TMR3C |= 0x08;
 655   4      
 656   4                              }
 657   3                      }       
 658   2              }
 659   1              else if(((PAREG&0x40))&&(key_flag))
 660   1              {
 661   2                      delay_20us(250);
 662   2                      if(((PAREG&0x40))&&(key_flag))    //按键松开
 663   2                      {
 664   3                              key_flag = 0;
 665   3                              alarm_flag = 0;
 666   3                              PWM_CTRL &= ~0x01;
 667   3                              bz_step = 0;
 668   3                              if(!silince_flag)
 669   3                              alarm_value = FIRE_ALARM_VALUE;
 670   3                              detect_count = 0;
 671   3                              detect_time = DETECT_TIME1;
 672   3                              sleep_flag = 1;
 673   3                              self_check_flag = 0;
 674   3                              lvd_time = 0;
 675   3      
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 12  

 676   3                              if(silince_flag)
 677   3                              silince_time = silince_time_bak;        
 678   3      
 679   3                              TMR3C &= ~0x08;         //关闭计数器
 680   3                              delay_20us(20);
 681   3                              TMR3L = 0x00;           //间隔8s
 682   3                              TMR3H = 0x06; 
 683   3                              TMR3C |= 0x08;
 684   3                      }
 685   2              }               
 686   1      
 687   1              if(((PAREG&0x02)==0x00)&&(!rxd_flag))
 688   1              {
 689   2                      delay_20us(1);
 690   2                      if(((PAREG&0x02)==0x00)&&(!rxd_flag))
 691   2                      {
 692   3                              rxd_flag = 1;
 693   3                              
 694   3                              MISC |= 0x80;   //复用uart口
 695   3                              SCON =  0X50;   //方式1,溢出率／３２
 696   3                              TTMOD2 = 0x00;  //使用timer1产生波特率，16位计数
 697   3                              TMOD = 0x00;    //不分频，４Ｍ
 698   3                              TH1 =  0X00;
 699   3                              TL1 = 0X0c;             //104ｕｓ，9600ｂｐｓ
 700   3                              TTCON = 0x2a;
 701   3                              INTMH &= ~0x02;
 702   3                              comm_step = 0;
 703   3                              timer_flag = 0xaa;      //进行一次采样
 704   3                              while(rxd_flag==1);
 705   3                              if(rxd_flag==4)           //读报警阈值
 706   3                              {
 707   4                                      timer_flag = 0;
 708   4                                      SBUF = alarm_value;
 709   4                                      while(rxd_flag);
 710   4                                      INTMH |= 0x02;
 711   4                                      MISC &= ~0x80;  //复用IO口
 712   4                              }
 713   3                              
 714   3                      }
 715   2              } 
 716   1      }
 717          
 718          
 719          void Other_Process()
 720          {
 721   1              if(silince_time>=SLIENCDE_TIME)           //消音时间到
 722   1              {
 723   2                      silince_flag = 0;
 724   2                      silince_time = 0;
 725   2                      silince_time_bak = 0;
 726   2                      alarm_value = FIRE_ALARM_VALUE; 
 727   2                      lvd_time = 0;
 728   2              }
 729   1      
 730   1              if(led_falg)
 731   1              {
 732   2                      led_falg = 0;
 733   2                      LED_ON();
 734   2                      delay_20us(250);
 735   2                      LED_OFF();
 736   2              }       
 737   1      //      if((!silince_flag)&&(!alarm_flag)&&(lvd_time>=LVD_TIME))           //低压报警
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 13  

 738   1              if((!alarm_flag)&&(lvd_time>=LVD_TIME))
 739   1              {
 740   2                      lvd_time = 0;
 741   2                      PWM_PULSE0L = 0x50;
 742   2                      PWM_PULSE0H = 0x02;
 743   2                      PWM_CTRL |= 0x40;
 744   2                      PWM_CTRL |= 0x01;
 745   2                      LED_ON();
 746   2                      delay_20us(250);
 747   2                      LED_OFF();
 748   2                      delay_20us(250);
 749   2                      PWM_CTRL &= ~0x01;
 750   2              }
 751   1      }
 752          
 753          
 754          void Sleep()
 755          {
 756   1              if(((SYS_REG4&0x10)==0x00)&&(sleep_flag))
 757   1              {
 758   2      //              sleep_flag = 0;
 759   2                      
 760   2                      BANDGAP_TEMP = 0X04; //关闭bandgap
 761   2                      LDO2_CTRL = 0x00;//关闭LDO2             
 762   2      //              delay_20us(20);
 763   2                      if(PAREG&0x40)            //未按按键开启pA6,pA1唤醒
 764   2                      WAKE_EN = 0x42;           //
 765   2                      PCON |= 0X02;   //mcu_stop                      
 766   2                      _nop_();
 767   2                      _nop_();
 768   2                      _nop_();
 769   2                      _nop_(); 
 770   2                  WAKE_EN = 0x00;     //关闭pA7唤醒
 771   2      //              PAREG = ~PAREG;
 772   2              
 773   2              } 
 774   1      
 775   1      }
 776          void delay_20us(unsigned char N)
 777          {
 778   1          unsigned char i;
 779   1          while(N--)     //6cycle
 780   1          {
 781   2              for(i=5;i>0;i--);
 782   2          }
 783   1      
 784   1      }
 785          
 786          
 787          void isr0()     using 0    interrupt 0
 788          {
 789   1      //              
 790   1      /*      if(TBC_INT&0x01)        //TB0中断固定8s
 791   1              {
 792   1                      if(!fast_flag)
 793   1                      {
 794   1                              TBC_INT = 0x00;
 795   1                              timer_flag += 8;
 796   1                              if(silince_flag)
 797   1                              silince_time += 8;
 798   1                              if(lvd_flag)
 799   1                          lvd_time += 8;
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 14  

 800   1                      }
 801   1                      else
 802   1                      TBC_INT &= ~0x01;
 803   1              }
 804   1              if(TBC_INT&0x02)        //唤醒加快时开启，TB1中断0.5s 
 805   1              {
 806   1                      TBC_INT &= ~0x02;
 807   1                      timer_flag++;
 808   1                      bz_timer++;
 809   1                      if(silince_flag)
 810   1                      silince_time++;
 811   1                      if(lvd_flag)
 812   1                  lvd_time++; 
 813   1      
 814   1      
 815   1              } */
 816   1              if(TMRINT&0X02)
 817   1              {
 818   2                      TMRINT &= ~0X02;
 819   2                      if(Charge_Flag==0)         //非电容充电唤醒
 820   2                      {       
 821   3                              timer_flag++;
 822   3                              bz_timer++;
 823   3                              if(silince_flag)
 824   3                              silince_time++;
 825   3                              if(lvd_flag)
 826   3                          lvd_time++;
 827   3                      }
 828   2      //              PAREG = ~PAREG;
 829   2              }       
 830   1      }
 831          
 832          
 833          
 834          
 835          /*void isr1()   using 1    interrupt 2            //uart中断
 836          {
 837                  unsigned char temp;
 838                  if(SCON&0X01)     //接收完成
 839                  {
 840                          SCON &= ~0X01;
 841                          temp = SBUF;
 842                          if(temp==0xaa)          //读烟雾值
 843                          rxd_flag = 2;
 844                          else if(temp==0xa0)             //读报警阈值
 845                          rxd_flag = 4;
 846                          else if(temp==0x55)             //标定
 847                          comm_step = 1;
 848                          else if (comm_step==1)
 849                          {
 850                                  delta_value =  temp;
 851                                  rxd_flag = 3;
 852                          }       
 853                  }
 854                  if(SCON&0X02)    //发送完成
 855                  {
 856                          SCON &= ~0X02;
 857                          rxd_flag = 0;
 858                  }
 859          }*/
 860          
 861          
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 15  

 862          
 863          void ser_int()
 864          {       
 865   1              TH1 = 0x00;
 866   1              TL1 = 0x33;               //2400波特率
 867   1              TTCON |= 0x02;    //T1定时周期配置有效
 868   1              TMOD = 0x00;      //T1预分频系数1
 869   1              TTCON = 0x28;     //T1使能，T1计数使能  
 870   1              TTMOD2 = 0x00;    //T1产生波特率，16位计数
 871   1              SCON = 0x50;      //串口允许接收,串口工作模式1
 872   1              SMOD = 0x00;
 873   1      }
 874          
 875          void uart()
 876          {
 877   1              if(uartr_flag == 2)
 878   1              {
 879   2               
 880   2                      WDCON |= 0x10;
 881   2                      BANDGAP_TEMP = 0x05;
 882   2                      LDO2_CTRL = 0x03;
 883   2      
 884   2                      Charge_Flag = 0;          
 885   2      
 886   2                      OPA1MODE = 0x10;        //配置成积分模式,并打开200mv偏置
 887   2                      OPA1C1 |= 0x01;         //开启运放              
 888   2                      LDOC = 0x46;
 889   2                      delay_20us(20);         //运放稳定时间
 890   2      
 891   2      /****************************************************/
 892   2                      BANDGAP_TEMP = 0x01;
 893   2                      OPA1MODE |= 0x01;       //Sw_integ
 894   2      
 895   2                      delay_20us(5);
 896   2      
 897   2                      OPA1MODE |= 0x02;
 898   2                      IRED_CTRL &= ~0x20;     //IRED关闭，积分保持
 899   2                      LDOC |= 0x20;           //打开LDO到ADC基准       
 900   2                      ADCR = 0x36;            //打开ADC电源，选择内部2.4V为基准
 901   2                      ADCR |= 0x80;
 902   2                      ADCR &= ~0x80;          //启动ADC检测
 903   2                      while(ADCR&0x40);       //等待ADC检测结束
 904   2                      Dark_Value = ADRH;      //暗电流检测，取ADC高8位
 905   2                      ADCR = 0x00;
 906   2                      LDOC &= ~0x20;
 907   2                      OPA1MODE &= ~0x03;
 908   2      
 909   2      /*****************必须按照该时序**************/         
 910   2                      OPA1MODE |= 0x02;
 911   2                      IRED_CTRL |= 0x20;      //IRED使能
 912   2                      OPA1MODE &= ~0x02;
 913   2                      OPA1MODE |= 0x01;       //Sw_integ
 914   2      
 915   2                      delay_20us(5);
 916   2      
 917   2                      OPA1MODE |= 0x02;        
 918   2                      IRED_CTRL &= ~0x20;     //IRED关闭，积分保持
 919   2      /********************************************/
 920   2      
 921   2                      LVDC |= 0x10;   //开启低压检测,需提前开启
 922   2      
 923   2                      LDOC |= 0x20;
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 16  

 924   2                      ADCR = 0x36;            //打开ADC电源，选择内部2.4V为基准
 925   2                      ADCR |= 0x80;
 926   2                      ADCR &= ~0x80;          //启动ADC检测
 927   2                      while(ADCR&0x40);       //等待ADC检测结束
 928   2                      Smoke_Value = ADRH;     //光电流检测，取ADC高8位
 929   2                      ADCR = 0x00;
 930   2                      LDOC = 0x00;
 931   2                      if(LVDC&0x20)
 932   2                      {
 933   3                          
 934   3                              lvd_flag = 1;
 935   3                      }
 936   2                      else
 937   2                      {
 938   3                              lvd_flag = 0;
 939   3                              lvd_time = 0;
 940   3                      }
 941   2                      LVDC &= ~0x10;  //关闭低压检测
 942   2      
 943   2                      OPA1MODE = 0x04;        //关闭所有开关并配置成开环模式
 944   2                      BANDGAP_TEMP = 0x04;
 945   2                      LDO2_CTRL = 0x00;//关闭LDO2
 946   2                      OPA1C1 &= ~0x01;        //关闭运放
 947   2                      
 948   2      
 949   2                      if(Smoke_Value>=Dark_Value)
 950   2                      Smoke_Value2 = Smoke_Value - Dark_Value;
 951   2                      else
 952   2                      Smoke_Value2 = 0; 
 953   2      
 954   2      
 955   2                      if(uartadd==0x68)
 956   2                      {
 957   3                              if(uartdate==0x81)
 958   3                              {
 959   4                                      delay_20us(1);
 960   4                                      SBUF = Dark_Value;
 961   4                                      uartr_flag = 3;
 962   4                              }
 963   3                              else
 964   3                              {       
 965   4                                      uartr_flag = 0;
 966   4                              }
 967   3                      }
 968   2                      else
 969   2                      {       
 970   3                              uartr_flag = 0;
 971   3                      }               
 972   2              }
 973   1      }
 974          
 975          
 976          
 977          void ser_uart() interrupt 2
 978          {
 979   1          //LED_ON()  ;
 980   1              if(SCON&0x01)
 981   1              {       
 982   2                 
 983   2                      SCON &= 0xfe;
 984   2                      uartdate = SBUF;
 985   2                      if(uartr_flag == 0)
C51 COMPILER V8.08   MAIN                                                                  08/12/2020 16:19:08 PAGE 17  

 986   2                      {                       
 987   3                              uartadd = uartdate;
 988   3                              uartr_flag++;
 989   3                      }
 990   2                      else if(uartr_flag == 1)
 991   2                      {       
 992   3                              uartr_flag++;
 993   3                      }
 994   2              }
 995   1              else if(SCON&0x02)
 996   1              {               
 997   2                      SCON &= 0xfd;
 998   2                      if(uartr_flag == 3)
 999   2                      {
1000   3                              SBUF = Smoke_Value;
1001   3                              uartr_flag = 4;
1002   3                      }
1003   2                      else if(uartr_flag == 4)
1004   2                      {
1005   3                              SBUF = Smoke_Value2;
1006   3                              uartr_flag = 0;
1007   3                      }                                       
1008   2              }
1009   1      }
1010          
1011          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2336    ----
   CONSTANT SIZE    =     44    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     38       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
